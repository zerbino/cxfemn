package ServerLifter;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.StringWriter;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import javax.xml.parsers.*;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.Marshaller;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;

import model.ServiceImpl;

import org.w3c.dom.DOMException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.UserDataHandler;
import org.xml.sax.SAXException;

import sun.tools.tree.ThisExpression;
import utile.UniformementRepresentable;

public class XSDLifter {
	/** Utilities**/
	public static String metaSchema;

	public static void marshall(
			Object o, String outputFile) {
		FileOutputStream out = null;
		try {
			SchemaFactory factory = SchemaFactory
					.newInstance("http://www.w3.org/2001/XMLSchema");
			Schema schema =null;
			out = new FileOutputStream(outputFile);
			schema = factory.newSchema(new File(metaSchema));
			JAXBContext jc = JAXBContext.newInstance("model");
			Marshaller m = jc.createMarshaller();
			m.setSchema(schema);
			//I noticed here you need to add tools.jar from the jdk to make the generation to jaxb classes possible
			m.marshal(o, out);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	public static Document getDOMTree(String xmlFile){
		try {
			// création d'une fabrique de documents
			DocumentBuilderFactory fabrique = DocumentBuilderFactory.newInstance();

			// création d'un constructeur de documents
			DocumentBuilder constructeur = fabrique.newDocumentBuilder();

			// lecture du contenu d'un fichier XML avec DOM
			File xml = new File(xmlFile);

			return constructeur.parse(xml);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}
	private static String convertDocumentToString(Node node) {
		TransformerFactory tf = TransformerFactory.newInstance();
		Transformer transformer;
		try {
			transformer = tf.newTransformer();
			// below code to remove XML declaration
			// transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
			StringWriter writer = new StringWriter();
			transformer.transform(new DOMSource(node), new StreamResult(writer));
			String output = writer.getBuffer().toString();
			return output;
		} catch (TransformerException e) {
			e.printStackTrace();
		}

		return null;
	}
	public static int treeSize(Node n, int i){
		if(n!=null && n.hasChildNodes()){
			i+=n.getChildNodes().getLength();
			if(i>0){
				NodeList nodes = n.getChildNodes();
				for(int index=0;index<i;index++){
					i+=treeSize(nodes.item(index),0);
				}
			}
		}
		return i;
	}
	/**Utilities**/
	/*protected static void treeInclusion(Document received,String wadlPath){
		Document expected=getDOMTree(wadlPath);
		String expectedRoot=expected.getElementsByTagName("xs:element").item(0).getAttributes().getNamedItem("type").getNodeValue();
		//we should check that the following node has the right attribute name (ie personne) instead of just taking the first
		if(expected.getElementsByTagName("xs:complexType").item(0).getChildNodes().getLength()!=treeSize(received,0)){
			try {
				received.renameNode(received.getChildNodes().item(0), "", expectedRoot);
				System.out.println(convertDocumentToString(received));
				//we should check that the following node has the right attribute name (ie personne) instead of just taking the first
				received=(Document) eraseExtraFields(received, expected.getElementsByTagName("xs:complexType").item(0));
				System.out.println(convertDocumentToString(received));
	
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}*/
	/** Lifting **/
	protected static void treeInclusion(Document received,String methodName,String className){
		LinkedList<Method> m=getMethod(methodName,className);
		Iterator<Method> it=m.iterator();
		Method service = null;
		//we find the right method that the user is calling.
		while(it.hasNext()){
			Method temp=it.next();
			if(temp.getParameterTypes().length==received.getChildNodes().getLength()){
				service=temp;
				break;
			}
		}
		if(service==null) return;
		//we assume that parameters are sorted
		//then we simply check the expected parameters match the received ones
		for(int i=0;i<received.getChildNodes().getLength();i++){
			if(!received.getChildNodes().item(i).getNodeName().equals(service.getParameterTypes()[i].getSimpleName())){
				try{
					//the following won't work if we don't have the full qualified name for the class we're looking for
					//unless we manage to get every class within the current project.
					//Class.forName(received.getChildNodes().item(i).getNodeName()).asSubclass(service.getParameterTypes()[i]);
					received.renameNode(received.getChildNodes().item(i), "", service.getParameterTypes()[i].getSimpleName());
					received=(Document) eraseExtraFields(received.getChildNodes().item(i),service.getParameterTypes()[i]);
					
				}
				catch(Exception e){

					return;
				}
			}
		}
		System.out.println(convertDocumentToString(received));
	}
	protected static Node eraseExtraFields(Node received, Class<?> class1) {
		Field[] f = class1.getDeclaredFields();
		System.out.println("here");
		boolean b;
		for(int i=0;i<received.getChildNodes().getLength();i++){
			b=true;
			for(int j=0;j<f.length;j++){
				if(f[j].getName().equals(received.getChildNodes().item(i).getNodeName())){
					b=false;
				}
			}
			if(b){
				received.removeChild(received.getChildNodes().item(i));
			}
		}
		return received;
	}
	public static LinkedList<Method> getMethod(String methodName, String className){
		LinkedList<Method> retour=new LinkedList<Method>();
		try {
			Class<?> c=Class.forName(className);
			 Method[] m=null;
			if (c!=null) m=c.getMethods();
			if(m!=null){
				for(int i=0;i<m.length;i++){
					if(m[i].getName().equals(methodName)){
						 retour.add(m[i]);
					}
				}
				System.out.println(UniformementRepresentable.toString(new StringBuilder(),m));
			}
		} catch (SecurityException | ClassNotFoundException e1) {
			e1.printStackTrace();
		}
		return retour;
	}
	
	/*public static Node eraseExtraFields(Node origine,Node authorizedAttributes){
		
		getTypeParameters("op",);
		
		System.out.println(convertDocumentToString(authorizedAttributes));
		//System.out.println(convertDocumentToString(authorizedAttributes.getChildNodes()));
		NodeList nodes = origine.getChildNodes();
		if(nodes!=null){
			boolean ok=false;
			for(int i=0;i<nodes.getLength();i++){
				if(nodes.item(i).getNodeName()!=null){
				//vérifier qu'on a le droit de copier
					for(int j=0;j<authorizedAttributes.getChildNodes().getLength();j++){
						if(authorizedAttributes.getChildNodes().item(j).getNodeName()=="xs:sequence"){
							for(int k=0;k<authorizedAttributes.getChildNodes().item(j).getChildNodes().getLength();k++){
								NamedNodeMap attributes = authorizedAttributes.getChildNodes().item(j).getChildNodes().item(k).getAttributes();
								try{
									System.out.println(attributes.getNamedItem(nodes.item(i).getNodeName()));
								}
								catch(Exception e){}
							}
							break;
						}
						if(authorizedAttributes.getChildNodes().item(j).getAttributes()!=null && authorizedAttributes.getChildNodes().item(j).getAttributes().getNamedItem(nodes.item(i).getNodeName())!=null){
							ok=true;
							break;
						}
					}
				}
				if(!ok){
					origine.removeChild(nodes.item(i));
				}
			}
		}
		return origine;

	}*/
	//the return String is the path to the doc output
	//normally lift should directly receive an xml file
	//objet o et le outputfile devraient etre remplacées par un Stream ou autre,
	//récupéré par l'intercepteur dans le content de la requete
	public static String Lift(Object o, String outputFile){
		//marshall(o,outputFile);
		Document doc = getDOMTree(outputFile);
		//System.out.println(convertDocumentToString(doc));
		//il faudra probablement faire quelque chose pour récupérer le nom de méthode dans webinf
		treeInclusion(doc,"op","model.ServiceImpl");
		return null;
	}
	/** Lifting **/
}
